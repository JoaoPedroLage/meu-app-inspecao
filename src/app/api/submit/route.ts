import { NextRequest, NextResponse } from 'next/server';
import { google } from 'googleapis';
import { Storage } from '@google-cloud/storage';
import nodemailer from 'nodemailer';
import { jsPDF } from 'jspdf';

// --- Interfaces para os dados do formul√°rio ---
interface HeaderData {
  departamento: string;
  encarregado: string;
  responsavelQSMS: string;
  gerenteContrato: string;
  unidade: string;
  data: string;
  hora: string;
  local: string;
  emailCompanhia: string;
}

interface Participant {
  nome: string;
  funcao: string;
}

interface InspectionItem {
  id: string;
  item: number;
  fato: string;
  recomendacoes: string;
  prazo: string;
  responsavel: string;
  conclusao: string;
  foto?: string; // Esperado como base64 data URL
}

interface ConclusionData {
  conclusaoGeral: string;
}

interface Signatures {
  responsavelInspecao: string; // Esperado como base64 data URL
  responsavelUnidade: string; // Esperado como base64 data URL
}

interface RequestBody {
  headerData: HeaderData;
  participants: Participant[];
  inspectionItems: InspectionItem[];
  conclusionData: ConclusionData;
  signatures: Signatures;
}

interface UploadResult {
  url: string;
  success: boolean;
  error?: string;
}

/**
 * Faz o upload de uma imagem para Google Cloud Storage com tratamento robusto de erros
 */
async function uploadImageToCloudStorage(base64Data: string, fileName: string): Promise<UploadResult> {
  console.log(`üöÄüöÄüöÄ ENTRANDO na uploadImageToCloudStorage para: ${fileName}`);
  
  // Verifica√ß√µes iniciais
  if (!base64Data || !base64Data.startsWith('data:image')) {
      console.log(`‚ùå SAINDO CEDO de uploadImageToCloudStorage para ${fileName}: dados inv√°lidos`);
      return { url: '', success: false, error: 'Dados de imagem inv√°lidos ou ausentes' };
  }

  const projectId = process.env.GOOGLE_CLOUD_PROJECT_ID;
  const bucketName = process.env.GOOGLE_CLOUD_STORAGE_BUCKET;

  if (!projectId || !bucketName) {
      const error = 'Configura√ß√µes do Google Cloud Storage n√£o encontradas nas vari√°veis de ambiente';
      console.error(`‚ö†Ô∏è ${error}`);
      return { url: '', success: false, error };
  }

  console.log(`‚úÖ PR√â-REQUISITOS OK para ${fileName}. Iniciando upload...`);

  try {
      const storage = new Storage({
          projectId,
          credentials: {
              client_email: process.env.GOOGLE_CLIENT_EMAIL,
              private_key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
          }
      });

      const bucket = storage.bucket(bucketName);

      // Processar a imagem base64
      const mimeType = base64Data.substring(base64Data.indexOf(':') + 1, base64Data.indexOf(';'));
      const imageData = base64Data.substring(base64Data.indexOf(',') + 1);
      const buffer = Buffer.from(imageData, 'base64');

      console.log(`üìä Dados da imagem:`, { mimeType, bufferSize: buffer.length, fileName });

      // Upload do arquivo
      const file = bucket.file(fileName);

      console.log(`üì§ Fazendo upload para Cloud Storage: gs://${bucketName}/${fileName}`);

      await file.save(buffer, {
          metadata: {
              contentType: mimeType,
              cacheControl: 'public, max-age=31536000',
          },
      });

      console.log(`‚úÖ Arquivo ${fileName} enviado com sucesso`);

      const publicUrl = `https://storage.googleapis.com/${bucketName}/${fileName}`;
      console.log(`üéâ Upload conclu√≠do: ${fileName} -> ${publicUrl}`);
      
      return { url: publicUrl, success: true };

  } catch (error) {
      let errorMessage = 'Erro desconhecido durante o upload.';
      if (error instanceof Error) {
          errorMessage = error.message;
      } else if (typeof error === 'object' && error !== null) {
          const gcpError = error as { errors?: { message?: string }[]; message?: string };
          errorMessage = gcpError.errors?.[0]?.message || gcpError.message || JSON.stringify(error);
      }

      console.error(`üí• ERRO DETALHADO no upload de ${fileName}:`, errorMessage);
      console.error(`Erro na √≠ntegra: `, error);

      return { url: '', success: false, error: errorMessage };
  }
}

/**
 * Verifica se a assinatura est√° em branco analisando os pixels da imagem
 */
function isSignatureBlank(base64Data: string): boolean {
  if (!base64Data || !base64Data.startsWith('data:image')) {
    return true;
  }

  try {
    const imageData = base64Data.substring(base64Data.indexOf(',') + 1);
    const buffer = Buffer.from(imageData, 'base64');

    if (buffer.length < 500) {
      return true;
    }

    const bufferString = buffer.toString('hex');
    const whitePixelPattern = /ffffff/g;
    const whitePixelMatches = bufferString.match(whitePixelPattern);
    const totalLength = bufferString.length;
    const whiteRatio = whitePixelMatches ? (whitePixelMatches.length * 6) / totalLength : 0;

    console.log(`üîç An√°lise da assinatura:`, {
      bufferSize: buffer.length,
      whiteRatio: whiteRatio.toFixed(3),
      isBlank: whiteRatio > 0.95 || buffer.length < 1000
    });

    return whiteRatio > 0.95 || buffer.length < 1000;

  } catch (error) {
    console.error('Erro ao analisar assinatura:', error);
    return false;
  }
}

/**
 * Gera PDF do relat√≥rio de inspe√ß√£o
 */
function generateInspectionPDF(
  data: RequestBody, 
  inspectionId: string, 
  signatureUrls: { signature1: string; signature2: string },
  evidenceUrls: { [key: number]: string }
): Buffer {
  const doc = new jsPDF();
  
  // Configura√ß√µes do PDF
  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 20;
  let yPosition = 20;
  
  // Fun√ß√£o para adicionar texto com quebra de linha
  const addText = (text: string, fontSize: number = 12, isBold: boolean = false) => {
    doc.setFontSize(fontSize);
    if (isBold) {
      doc.setFont('helvetica', 'bold');
    } else {
      doc.setFont('helvetica', 'normal');
    }
    
    const lines = doc.splitTextToSize(text, pageWidth - 2 * margin);
    lines.forEach((line: string) => {
      if (yPosition > doc.internal.pageSize.getHeight() - 20) {
        doc.addPage();
        yPosition = 20;
      }
      doc.text(line, margin, yPosition);
      yPosition += fontSize * 0.4;
    });
    yPosition += 5;
  };

  // Fun√ß√£o para adicionar link clic√°vel
  const addLink = (text: string, url: string, fontSize: number = 10) => {
    doc.setFontSize(fontSize);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(0, 0, 255); // Cor azul para links
    
    const lines = doc.splitTextToSize(text, pageWidth - 2 * margin);
    const startY = yPosition;
    
    lines.forEach((line: string) => {
      if (yPosition > doc.internal.pageSize.getHeight() - 20) {
        doc.addPage();
        yPosition = 20;
      }
      doc.text(line, margin, yPosition);
      yPosition += fontSize * 0.4;
    });
    
    // Adicionar anota√ß√£o de link usando coordenadas corretas
    const textHeight = fontSize * 0.4;
    const linkHeight = lines.length * textHeight;
    doc.link(margin, startY - textHeight, pageWidth - 2 * margin, linkHeight, { url: url });
    
    yPosition += 5;
    
    // Resetar cor para texto normal
    doc.setTextColor(0, 0, 0);
  };

  // Cabecalho
  addText('RELATORIO DE INSPECAO', 16, true);
  addText(`ID: ${inspectionId}`, 12, true);
  addText(`Data: ${data.headerData.data} | Hora: ${data.headerData.hora}`, 10);
  yPosition += 10;

  // Dados do cabecalho
  addText('DADOS DA INSPECAO', 14, true);
  addText(`Departamento: ${data.headerData.departamento}`, 10);
  addText(`Encarregado: ${data.headerData.encarregado}`, 10);
  addText(`Responsavel QSMS: ${data.headerData.responsavelQSMS}`, 10);
  addText(`Gerente de Contrato: ${data.headerData.gerenteContrato}`, 10);
  addText(`Unidade: ${data.headerData.unidade}`, 10);
  addText(`Local: ${data.headerData.local}`, 10);
  addText(`E-mail: ${data.headerData.emailCompanhia}`, 10);
  yPosition += 10;

  // Participantes
  addText('PARTICIPANTES', 14, true);
  data.participants.forEach((participant, index) => {
    addText(`${index + 1}. ${participant.nome} - ${participant.funcao}`, 10);
  });
  yPosition += 10;

  // Itens de inspecao
  if (data.inspectionItems.length > 0) {
    addText('ITENS DE INSPECAO', 14, true);
    data.inspectionItems.forEach((item, index) => {
      addText(`Item ${item.item}:`, 12, true);
      addText(`Fato Observado: ${item.fato}`, 10);
      
      // Evidencia fotografica com hyperlink
      const evidenceUrl = evidenceUrls[index];
      addText('Evidencia Fotografica:', 10);
      if (evidenceUrl && evidenceUrl !== 'Nenhuma' && !evidenceUrl.includes('‚ùå')) {
        addLink('Ver Evidencia', evidenceUrl, 10);
      } else if (evidenceUrl && evidenceUrl.includes('‚ùå')) {
        addText(evidenceUrl, 10);
      } else {
        addText('Nenhuma', 10);
      }
      
      addText(`Recomenda√ß√µes: ${item.recomendacoes}`, 10);
      addText(`Prazo: ${item.prazo}`, 10);
      addText(`Respons√°vel: ${item.responsavel}`, 10);
      addText(`Conclus√£o: ${item.conclusao}`, 10);
      yPosition += 5;
    });
  }

  // Conclusao geral
  addText('CONCLUSAO GERAL', 14, true);
  addText(data.conclusionData.conclusaoGeral, 10);
  yPosition += 10;

  // Assinaturas
  addText('ASSINATURAS', 14, true);
  
  // Assinatura 1
  addText('Responsavel pela Inspecao:', 10, true);
  if (signatureUrls.signature1 && signatureUrls.signature1 !== 'N√£o assinado' && !signatureUrls.signature1.includes('‚ùå')) {
    addLink('Ver Assinatura', signatureUrls.signature1, 10);
  } else {
    addText(signatureUrls.signature1.includes('‚ùå') ? signatureUrls.signature1 : 'N√£o assinado', 10);
  }
  
  // Assinatura 2
  addText('Responsavel da Unidade:', 10, true);
  if (signatureUrls.signature2 && signatureUrls.signature2 !== 'N√£o assinado' && !signatureUrls.signature2.includes('‚ùå')) {
    addLink('Ver Assinatura', signatureUrls.signature2, 10);
  } else {
    addText(signatureUrls.signature2.includes('‚ùå') ? signatureUrls.signature2 : 'N√£o assinado', 10);
  }

  return Buffer.from(doc.output('arraybuffer'));
}

/**
 * Envia e-mail com PDF anexado
 */
async function sendEmailWithPDF(email: string, pdfBuffer: Buffer, inspectionId: string): Promise<boolean> {
  try {
    // Configura√ß√£o do transporter (usando Gmail como exemplo)
    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
      },
    });

    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: email,
      subject: `Relat√≥rio de Inspe√ß√£o - ${inspectionId}`,
      text: `Segue em anexo o relat√≥rio de inspe√ß√£o ${inspectionId}.`,
      attachments: [
        {
          filename: `relatorio_inspecao_${inspectionId}.pdf`,
          content: pdfBuffer,
          contentType: 'application/pdf',
        },
      ],
    };

    await transporter.sendMail(mailOptions);
    console.log(`‚úÖ E-mail enviado com sucesso para: ${email}`);
    return true;
  } catch (error) {
    console.error('‚ùå Erro ao enviar e-mail:', error);
    return false;
  }
}

/**
 * Fun√ß√£o para testar conectividade com Google Cloud Storage
 */
async function testCloudStorageConnection(): Promise<boolean> {
  console.log("üîß TESTE DE CONECTIVIDADE - Iniciando teste do Google Cloud Storage...");

  try {
    const projectId = process.env.GOOGLE_CLOUD_PROJECT_ID;
    const bucketName = process.env.GOOGLE_CLOUD_STORAGE_BUCKET;

    if (!projectId || !bucketName) {
      console.log("‚ùå Configura√ß√µes do Google Cloud Storage n√£o encontradas");
      return false;
    }

    const storage = new Storage({
      projectId,
      credentials: {
        client_email: process.env.GOOGLE_CLIENT_EMAIL,
        private_key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
      }
    });

    console.log("üìã Teste 1: Verificando acesso ao projeto...");
    const [buckets] = await storage.getBuckets();
    console.log("‚úÖ Teste 1 PASSOU:", {
      projeto: projectId,
      bucketsEncontrados: buckets.length,
      primeirosBuckets: buckets.slice(0, 3).map((bucket) => bucket.name)
    });

    console.log("üìã Teste 2: Verificando bucket espec√≠fico...");
    const bucket = storage.bucket(bucketName);
    const [exists] = await bucket.exists();

    if (!exists) {
      console.log(`‚ö†Ô∏è Bucket ${bucketName} n√£o existe, mas pode ser criado automaticamente`);
    } else {
      console.log("‚úÖ Teste 2 PASSOU:", {
        bucketName,
        exists: true
      });
    }

    console.log("üéâ TODOS OS TESTES DE CLOUD STORAGE PASSARAM!");
    return true;

  } catch (error) {
    console.error("üí• FALHA NO TESTE DE CLOUD STORAGE:");
    console.error("Tipo:", typeof error);
    console.error("Mensagem:", error instanceof Error ? error.message : String(error));

    return false;
  }
}

// --- Handler principal da API (usando App Router) ---
export async function POST(request: NextRequest) {
  console.log("üî• API ROUTE: Recebendo requisi√ß√£o POST");

  try {
    console.log("üì• Tentando fazer parse do JSON...");
    const body: RequestBody = await request.json();
    console.log("‚úÖ JSON parseado com sucesso");

    const { headerData, participants, inspectionItems, conclusionData, signatures } = body;

    console.log("üìä Dados recebidos:", {
      headerData: !!headerData,
      participantsCount: participants?.length || 0,
      itemsCount: inspectionItems?.length || 0,
      hasConclusion: !!conclusionData?.conclusaoGeral,
      hasSignatures: !!(signatures?.responsavelInspecao && signatures?.responsavelUnidade)
    });

    // Configura√ß√£o das vari√°veis de ambiente com valida√ß√£o
    const privateKey = process.env.GOOGLE_PRIVATE_KEY;
    if (!privateKey) {
      console.log("‚ùå GOOGLE_PRIVATE_KEY n√£o encontrada");
      throw new Error('GOOGLE_PRIVATE_KEY n√£o encontrada');
    }

    const clientEmail = process.env.GOOGLE_CLIENT_EMAIL;
    if (!clientEmail) {
      console.log("‚ùå GOOGLE_CLIENT_EMAIL n√£o encontrada");
      throw new Error('GOOGLE_CLIENT_EMAIL n√£o encontrada');
    }

    // Autentica√ß√£o para Google Sheets
    const auth = new google.auth.GoogleAuth({
      credentials: {
        client_email: clientEmail,
        private_key: privateKey.replace(/\\n/g, '\n'),
      },
      scopes: ['https://www.googleapis.com/auth/spreadsheets'],
    });
    console.log(`üîê Autentica√ß√£o configurada com: ${clientEmail}`);

    // *** TESTE DE CONECTIVIDADE com Cloud Storage ***
    console.log("üöÄ Executando teste de conectividade com Google Cloud Storage...");
    const storageConnected = await testCloudStorageConnection();

    if (!storageConnected) {
      console.log("‚ùå Conex√£o com Google Cloud Storage falhou, mas continuando...");
    }

    const sheets = google.sheets({ version: 'v4', auth });
    const spreadsheetId = process.env.GOOGLE_SHEET_ID;

    console.log("üìä GOOGLE_SHEET_ID:", spreadsheetId);
    if (!spreadsheetId) {
      console.log("‚ùå GOOGLE_SHEET_ID n√£o encontrada");
      throw new Error('GOOGLE_SHEET_ID n√£o encontrada');
    }

    // Prepara√ß√£o dos dados para a planilha
    const inspectionId = `INSPEC-${Date.now()}`;
    const participantNames = participants.map(p => p.nome).join(', ');
    const participantFunctions = participants.map(p => p.funcao).join(', ');

    // Preparar URLs para o PDF (ser√£o preenchidas ap√≥s o upload das imagens)
    const signatureUrls = { signature1: 'N√£o assinado', signature2: 'N√£o assinado' };
    const evidenceUrls: { [key: number]: string } = {};

    // Verificar se as assinaturas est√£o em branco
    const signature1IsBlank = signatures.responsavelInspecao === 'N√£o assinado' || isSignatureBlank(signatures.responsavelInspecao);
    const signature2IsBlank = signatures.responsavelUnidade === 'N√£o assinado' || isSignatureBlank(signatures.responsavelUnidade);

    console.log("‚úçÔ∏è Status das assinaturas:", {
      signature1IsBlank,
      signature2IsBlank,
      signature1Type: typeof signatures.responsavelInspecao,
      signature2Type: typeof signatures.responsavelUnidade,
      signature1Preview: signatures.responsavelInspecao.substring(0, 50) + '...'
    });

    // Upload das assinaturas para Cloud Storage com tratamento de erros
    console.log(`üß™ Testando upload das assinaturas...`);

    const signature1Result: UploadResult = signature1IsBlank ?
      { url: '', success: true, error: 'Assinatura n√£o fornecida' } :
      await uploadImageToCloudStorage(signatures.responsavelInspecao, `assinaturas/Assinatura_Inspecao_${inspectionId}.png`);

    const signature2Result: UploadResult = signature2IsBlank ?
      { url: '', success: true, error: 'Assinatura n√£o fornecida' } :
      await uploadImageToCloudStorage(signatures.responsavelUnidade, `assinaturas/Assinatura_Unidade_${inspectionId}.png`);

    console.log(`üìã Resultados dos uploads de assinatura:`, {
      signature1: {
        success: signature1Result.success,
        url: signature1Result.url || 'Vazio',
        error: signature1Result.error || 'N/A'
      },
      signature2: {
        success: signature2Result.success,
        url: signature2Result.url || 'Vazio',
        error: signature2Result.error || 'N/A'
      }
    });
    
    // L√≥gica para determinar o texto/link das assinaturas
    // Esta l√≥gica foi movida para fora do loop .map para funcionar corretamente
    // tanto para casos com itens de inspe√ß√£o quanto para casos sem itens.
    let signatureLink1 = 'N√£o assinado';
    if (!signature1IsBlank) {
      if (signature1Result.success && signature1Result.url) {
        signatureLink1 = `=HYPERLINK("${signature1Result.url}"; "Ver Assinatura")`;
        signatureUrls.signature1 = signature1Result.url; // URL para o PDF
      } else {
        signatureLink1 = `‚ùå Falha no upload: ${signature1Result.error || 'Erro desconhecido'}`;
        signatureUrls.signature1 = `‚ùå Falha no upload: ${signature1Result.error || 'Erro desconhecido'}`;
      }
    }

    let signatureLink2 = 'N√£o assinado';
    if (!signature2IsBlank) {
      if (signature2Result.success && signature2Result.url) {
        signatureLink2 = `=HYPERLINK("${signature2Result.url}"; "Ver Assinatura")`;
        signatureUrls.signature2 = signature2Result.url; // URL para o PDF
      } else {
        signatureLink2 = `‚ùå Falha no upload: ${signature2Result.error || 'Erro desconhecido'}`;
        signatureUrls.signature2 = `‚ùå Falha no upload: ${signature2Result.error || 'Erro desconhecido'}`;
      }
    }

    // Mapear os itens e fazer upload das evid√™ncias com tratamento de erros
    console.log(`üì∑ Processando ${inspectionItems.length} itens de inspe√ß√£o...`);

    const rowsToAppend = await Promise.all(
      inspectionItems.map(async (item, index) => {
        console.log(`üì∏ Processando item ${index + 1}:`, {
          hasPhoto: !!item.foto,
          photoType: typeof item.foto
        });

        let photoResult: UploadResult = { url: '', success: true, error: 'Nenhuma foto fornecida' };

        if (item.foto && item.foto !== 'Nenhuma') {
          photoResult = await uploadImageToCloudStorage(item.foto, `evidencias/Evidencia_${inspectionId}_Item_${index + 1}.png`);
        }

        console.log(`üì∏ Resultado do upload da evid√™ncia ${index + 1}:`, {
          success: photoResult.success,
          url: photoResult.url || 'Vazio',
          error: photoResult.error || 'N/A'
        });

        // Determinar o texto para a coluna de evid√™ncia
        let evidenceText = 'Nenhuma';
        if (item.foto && item.foto !== 'Nenhuma') {
          if (photoResult.success && photoResult.url) {
            evidenceText = `=HYPERLINK("${photoResult.url}"; "Ver Evid√™ncia")`;
            evidenceUrls[index] = photoResult.url; // URL para o PDF
          } else {
            evidenceText = `‚ùå Falha no upload: ${photoResult.error || 'Erro desconhecido'}`;
            evidenceUrls[index] = `‚ùå Falha no upload: ${photoResult.error || 'Erro desconhecido'}`;
          }
        } else {
          evidenceUrls[index] = 'Nenhuma';
        }

        return [
          inspectionId,
          headerData.data || '',
          headerData.hora || '',
          headerData.departamento || '',
          headerData.encarregado || '',
          headerData.responsavelQSMS || '',
          headerData.gerenteContrato || '',
          headerData.unidade || '',
          headerData.local || '',
          headerData.emailCompanhia || '',
          participantNames,
          participantFunctions,
          item.fato || '',
          item.recomendacoes || '',
          item.prazo || '',
          item.responsavel || '',
          item.conclusao || '',
          evidenceText,
          conclusionData.conclusaoGeral || '',
          signatureLink1,
          signatureLink2,
        ];
      })
    );

    // Tratamento para formul√°rios sem itens de inspe√ß√£o
    // Esta se√ß√£o agora usa as vari√°veis de assinatura pr√©-calculadas corretamente
    if (rowsToAppend.length === 0) {
      rowsToAppend.push([
        inspectionId, headerData.data || '', headerData.hora || '', headerData.departamento || '',
        headerData.encarregado || '', headerData.responsavelQSMS || '', headerData.gerenteContrato || '',
        headerData.unidade || '', headerData.local || '', headerData.emailCompanhia || '', participantNames, participantFunctions,
        'N/A', 'Nenhum item de inspe√ß√£o foi adicionado.', '', '', '', 'Nenhuma',
        conclusionData.conclusaoGeral || '',
        signatureLink1,
        signatureLink2,
      ]);
    }

    console.log("üìù Dados formatados para planilha:", rowsToAppend.length, "linhas");

    // Gerar PDF do relat√≥rio com URLs das assinaturas e evid√™ncias
    console.log("üìÑ Gerando PDF do relat√≥rio...");
    const pdfBuffer = generateInspectionPDF(body, inspectionId, signatureUrls, evidenceUrls);
    console.log("‚úÖ PDF gerado com sucesso");

    // Enviar e-mail com PDF se o e-mail foi fornecido
    if (headerData.emailCompanhia && headerData.emailCompanhia.trim() !== '') {
      console.log(`üìß Enviando e-mail para: ${headerData.emailCompanhia}`);
      const emailSent = await sendEmailWithPDF(headerData.emailCompanhia, pdfBuffer, inspectionId);
      if (emailSent) {
        console.log("‚úÖ E-mail enviado com sucesso");
      } else {
        console.log("‚ö†Ô∏è Falha no envio do e-mail, mas continuando com o processo");
      }
    } else {
      console.log("‚ö†Ô∏è E-mail da companhia n√£o fornecido, pulando envio de e-mail");
    }

    console.log("üì§ Enviando para Google Sheets...");
    const appendResponse = await sheets.spreadsheets.values.append({
      spreadsheetId,
      range: 'Mapa de Controle!A:V',
      valueInputOption: 'USER_ENTERED',
      requestBody: {
        values: rowsToAppend,
      },
    });

    console.log("‚úÖ Dados inseridos com sucesso:", {
      updates: appendResponse.data.updates
    });

    return NextResponse.json({ message: 'Dados inseridos com sucesso', inspectionId }, { status: 200 });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Erro desconhecido';
    console.error("üí• ERRO na API ROUTE:");
    console.error("Tipo:", typeof error);
    console.error("Mensagem:", errorMessage);
    console.error("Stack:", error instanceof Error ? error.stack : 'N/A');

    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
